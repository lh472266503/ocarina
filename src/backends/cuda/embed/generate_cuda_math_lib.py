from ast import operator
from ctypes import alignment
from dataclasses import field
from os.path import realpath, dirname
import os
from posixpath import split

scalar_types = ["int", "uint", "float", "bool", "uchar", "ushort", "ulong"]
native_types = ["int", "unsigned int", "float", "bool", "unsigned char", "unsigned short", "unsigned long long"]
vector_alignments = {2: 8, 3: 16, 4: 16}
indent = "\t"
name_lst = ["x", "y", "z", "w"]
device_flag = "__device__"

prefix = "oc"

cur_fn = os.path.basename(__file__)

def file_head():
    return f"// this file was generated by {cur_fn}, please do not manually modify \n \n"

content = file_head() + "#pragma once\n\n"

def get_indent(num = 1):
    return indent * num

def using_scalar():
    global content
    string = ""
    for i,scalar in enumerate(scalar_types):
        string += f"using {prefix}_{scalar} = {native_types[i]};\n"
    
    content += string

def emit_member(scalar_name, dim):
    ret = "\n"
    for d in range(0, dim):
        ret += indent + scalar_name + " " + name_lst[d] + ";\n"
    return ret

def emit_functions(scalar_name, dim):
    ret = "\n"
    struct_name = f"{scalar_name}{dim}"

    ret += indent + f"{device_flag} {struct_name}() noexcept \n" + get_indent(2) + ":"
    for d in range(0, dim):
        split = ", " if d != dim - 1 else ""
        ret += f"{name_lst[d]}{{}}" + split 
    ret += " {}\n"

    ret += indent + f"{device_flag} {struct_name}({scalar_name} s) noexcept \n" + get_indent(2) + ":"
    for d in range(0, dim):
        split = ", " if d != dim - 1 else ""
        ret += f"{name_lst[d]}(s)" + split 
    ret += " {}\n"

    args = ""
    assign = ""
    for d in range(0, dim):
        split = ", " if d != dim - 1 else ""
        member_name = name_lst[d]
        args += f"{scalar_name} {member_name}" + split
        assign += f"{member_name}({member_name})" + split 
    ret += indent + f"{device_flag} {struct_name}({args}) noexcept \n" + get_indent(2) + ":"
    ret += assign
    ret += " {}\n"

    access = f"{device_flag} inline {scalar_name} operator[]({prefix}_uint i) const noexcept %s\n" % ("{ return (&x)[i]; }")
    access += indent + f"{device_flag} inline {scalar_name} &operator[]({prefix}_uint i) noexcept %s\n" % ("{ return (&x)[i]; }")
    ret += indent + access

    return ret

def define_vector():
    global content
    content += "\n"
    for j, scalar in enumerate(scalar_types):
        for dim in range(2, 5):
            alignment = vector_alignments[dim]
            scalar_name = f"{prefix}_{scalar}"
            struct_name = f"struct alignas({alignment}) {scalar_name}{dim}" + "{"
            content += struct_name
            body = emit_member(scalar_name, dim)
            body += emit_functions(scalar_name, dim)
            content += body
            content += "};\n\n"
            
def define_array():
    global content
    content += "\n"
    string = """
template<typename T, oc_uint N>
class oc_array {
private:
    T _data[N];

public:
    template<typename... Elem>
    __device__ constexpr oc_array(Elem... elem) noexcept : _data{elem...} {}
    __device__ constexpr oc_array(oc_array &&) noexcept = default;
    __device__ constexpr oc_array(const oc_array &) noexcept = default;
    __device__ constexpr oc_array &operator=(oc_array &&) noexcept = default;
    __device__ constexpr oc_array &operator=(const oc_array &) noexcept = default;
    [[nodiscard]] __device__ T &operator[](size_t i) noexcept { return _data[i]; }
    [[nodiscard]] __device__ T operator[](size_t i) const noexcept { return _data[i]; }
};
"""

    content +=string

def define_array_unary(unary):
    global content
    for op in unary:            
        func = f"""
template<typename T, oc_uint N>
{device_flag} oc_array<T, N> operator{op}(oc_array<T, N> arg) {{
    oc_array<T, N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = {op}arg[i];
    }}
    return ret;
}}
"""
        content += func
        
def define_array_binary(cal_binary, cmp_binary, bit_binary):
    global content
    binary = cal_binary + cmp_binary + bit_binary
    for op in cal_binary:
        func = f"""
template<typename T,typename U, oc_uint N>
{device_flag} auto operator{op}(oc_array<T, N> lhs, oc_array<U, N> rhs) {{
    oc_array<decltype(T{{}} {op} U{{}}), N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs[i] {op} rhs[i];
    }}
    return ret;
}}

template<typename T,typename U>
{device_flag} auto operator{op}(oc_array<T, 1> lhs, oc_array<U, 1> rhs) {{
    oc_array<decltype(T{{}} {op} U{{}}), 1> ret;
    ret[0] = lhs[0] {op} rhs[0];
    return ret;
}}

template<typename T,typename U, oc_uint N>
{device_flag} auto operator{op}(oc_array<T, N> lhs, U rhs) {{
    oc_array<decltype(T{{}} {op} U{{}}), N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs[i] {op} rhs;
    }}
    return ret;
}}

template<typename T,typename U, oc_uint N>
{device_flag} auto operator{op}(oc_array<T, N> lhs, oc_array<U, 1> rhs) {{
    return lhs {op} rhs[0];
}}

template<typename T,typename U, oc_uint N>
{device_flag} auto operator{op}(T lhs, oc_array<U, N> rhs) {{
    oc_array<decltype(T{{}} {op} U{{}}), N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs {op} rhs[i];
    }}
    return ret;
}}

template<typename T,typename U, oc_uint N>
{device_flag} auto operator{op}(oc_array<T, 1> lhs, oc_array<U, N> rhs) {{
    return lhs[0] {op} rhs;
}}
"""
        content += func
        
    for op in cmp_binary:
        func = f"""
template<typename T, typename U, oc_uint N>
{device_flag} oc_array<oc_bool, N> operator{op}(oc_array<T, N> lhs, oc_array<U, N> rhs) {{
    oc_array<oc_bool, N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs[i] {op} rhs[i];
    }}
    return ret;
}}

template<typename T,typename U, oc_uint N>
{device_flag} oc_array<oc_bool, N> operator{op}(oc_array<T, N> lhs, U rhs) {{
    oc_array<oc_bool, N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs[i] {op} rhs;
    }}
    return ret;
}}

template<typename T, typename U, oc_uint N>
{device_flag} oc_array<oc_bool, N> operator{op}(oc_array<T, N> lhs, oc_array<U, 1> rhs) {{    
    oc_array<oc_bool, N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs[i] {op} rhs[0];
    }}
    return ret;
}}

template<typename T, typename U, oc_uint N>
{device_flag} oc_array<oc_bool, N> operator{op}(T lhs, oc_array<U, N> rhs) {{
    oc_array<oc_bool, N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs {op} rhs[i];
    }}
    return ret;
}}

template<typename T, typename U, oc_uint N>
{device_flag} oc_array<oc_bool, N> operator{op}(oc_array<T, 1> lhs, oc_array<U, N> rhs) {{
    oc_array<oc_bool, N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs[0] {op} rhs[i];
    }}
    return ret;
}}


"""
        content += func

    for op in bit_binary:
        func = f"""
template<typename T, typename U, oc_uint N>
{device_flag} auto operator{op}(oc_array<T, N> lhs, oc_array<U, N> rhs) {{
    oc_array<decltype(T{{}} {op} U{{}}), N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs[i] {op} rhs[i];
    }}
    return ret;
}}

template<typename T, typename U, oc_uint N>
{device_flag} auto operator{op}(oc_array<T, N> lhs, U rhs) {{
    oc_array<decltype(T{{}} {op} U{{}}), N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs[i] {op} rhs;
    }}
    return ret;
}}

template<typename T, typename U, oc_uint N>
{device_flag} auto operator{op}(oc_array<T, N> lhs, oc_array<U, 1> rhs) {{
    return lhs {op} rhs[0];
}}

template<typename T, typename U, oc_uint N>
{device_flag} auto operator{op}(T lhs, oc_array<U, N> rhs) {{
    oc_array<decltype(T{{}} {op} U{{}}), N> ret;
    for(oc_uint i = 0u; i < N; ++i) {{
        ret[i] = lhs {op} rhs[i];
    }}
    return ret;
}}

template<typename T, typename U, oc_uint N>
{device_flag} auto operator{op}(oc_array<T, 1> lhs, oc_array<U, N> rhs) {{
    return lhs[0] {op} rhs;
}}
"""
        content += func


def define_operator():
    global content
    unary = ["+", "-", "!", "~"]
    define_array_unary(unary)    
    for i, scalar in enumerate(scalar_types):
        for dim in range(2, 5):
            for op in unary:
                if op == "~" and scalar == "float":
                    continue
                class_name = f"{prefix}_{scalar}{dim}"
                args = ""
                for d in range(0, dim):
                    split = ", " if d != dim - 1 else ""
                    args += f"{op}vec.{name_lst[d]}" + split
                func = f"{device_flag} {class_name} operator{op}({class_name} vec) {{ return {class_name}({args}); }}"
                content += func + "\n"
            content += "\n"
    content += "\n"     
    cal_binary = ["+", "-", "*", "/", "%"]
    cmp_binary = ["==", "!=", ">" , "<", ">=", "<=","&&", "||"]
    bit_binary = ["&", "|", "^", "<<", ">>"]
    
    define_array_binary(cal_binary, cmp_binary, bit_binary)
    
    binary = cal_binary + cmp_binary + bit_binary
    for i, scalar in enumerate(scalar_types):
        for dim in range(2, 5):
            for op in binary:
                if scalar == "bool" and (op in cal_binary):
                    continue
                if scalar == "float" and (op == "%" or op in bit_binary):
                    continue
                vec_name = f"{prefix}_{scalar}{dim}"
                ret_type = vec_name
                if op in cmp_binary:
                    ret_type = f"{prefix}_bool{dim}"
                scalar_name = f"{prefix}_{scalar}"
                args = ""
                args1 = ""
                args2 = ""
                for d in range(0, dim):
                    field_name = name_lst[d]
                    split = ", " if d != dim - 1 else ""
                    args += f"lhs.{field_name} {op} rhs.{field_name}" + split
                    args1 += f"lhs.{field_name} {op} rhs" + split
                    args2 += f"lhs {op} rhs.{field_name}" + split
                    
                func = f"{device_flag} {ret_type} operator{op}({vec_name} lhs, {vec_name} rhs) {{ return {ret_type}({args}); }}\n"
                func += f"{device_flag} {ret_type} operator{op}({vec_name} lhs, {scalar_name} rhs) {{ return {ret_type}({args1}); }}\n"
                func += f"{device_flag} {ret_type} operator{op}({scalar_name} lhs, {vec_name} rhs) {{ return {ret_type}({args2}); }}\n"
                content += func
        content += "\n"

    for i,scalar in enumerate(scalar_types[:3]):
        for dim in range(2, 5):
            for op in cal_binary:
                if scalar == "float" and op == "%":
                    continue
                vec_name = f"{prefix}_{scalar}{dim}"
                func = f"__device__ {vec_name}& operator{op}=({vec_name} &lhs, {vec_name} rhs) {{ lhs = lhs {op} rhs; return lhs; }}\n"
                content += func
        content += "\n"

    func_lst = ["oc_any", "oc_all", "oc_none"]
    for func in func_lst:
        op = " || " if func == "oc_any" else " && "
        for dim in range(2, 5):
            ret_type = f"{prefix}_bool"
            arg_type = f"{prefix}_bool{dim}"
            ret = ""
            if func != "oc_none":
                for d in range(0, dim):
                    split = op if d != dim - 1 else ""
                    field_name = name_lst[d]
                    ret += f"vec.{field_name}" + split
            else:
                ret = "!oc_any(vec)"
                
            string = f"{device_flag} {ret_type} {func}({arg_type} vec) {{ return {ret}; }}" 
            content += string + "\n"
            
    fun = f"""
template<oc_uint N>
[[nodiscard]] oc_bool oc_any(oc_array<oc_bool, N> arg) {{
    oc_bool ret = arg[0];
    for(oc_uint i = 1u; i < N; ++i) {{
        ret = ret || arg[i];
    }}
    return ret;
}}

template<oc_uint N>
[[nodiscard]] oc_bool oc_all(oc_array<oc_bool, N> arg) {{
    oc_bool ret = arg[0];
    for(oc_uint i = 1u; i < N; ++i) {{
        ret = ret && arg[i];
    }}
    return ret;
}}

template<oc_uint N>
[[nodiscard]] oc_bool oc_none(oc_array<oc_bool, N> arg) {{
    return !oc_any(arg);
}}

"""
    content += fun
    content += "\n"
    
def define_matrix():
    global content
    struct = ""
    for dim in range(2, 5):
        struct = f"struct {prefix}_float{dim}x{dim} {{\n"
        struct_name = f"{prefix}_float{dim}x{dim}"
        struct += get_indent(1) + f"{prefix}_float{dim} cols[{dim}];\n"
        struct += get_indent(1) + f"__device__ explicit inline {prefix}_float{dim}x{dim}({prefix}_float s = 1.f)\n"
        args = ""
        for d in range(0, dim):
            split = ", " if d != dim - 1 else ""

            vec = f"{prefix}_float{dim}("
            for j in range(0, dim):
                split_j = ", " if j != dim - 1 else ")"
                scalar = "s" if j == d else "0.f"
                vec += scalar + split_j
            args += vec + split
        struct += get_indent(2) + f":cols{{{args}}} {{}}\n"
        
        args = ""
        lst = ""
        for d in range(0, dim):
            split = ", " if d != dim - 1 else ""
            args += f"{prefix}_float{dim} c{d}" + split
            lst += f"c{d}" + split
        struct += get_indent(1) + f"__device__ {prefix}_float{dim}x{dim}({args})\n"
        struct += get_indent(2) + f":cols{{{lst}}} {{}}\n"

        args = ""
        body = f":{struct_name}("
        for i in range(0, dim):
            col = f"oc_float{dim}("
            for j in range(0, dim):
                split = ", " if i * j != (dim - 1)**2 else ""
                split_col = ", " if j != dim - 1 else ")"
                args += f"{prefix}_float m{i}{j}" + split
                col += f"m{i}{j}" + split_col
            split_body = ", " if i != dim - 1 else ")"
            body += col + split_body
        struct += get_indent(1) + f"__device__ {struct_name} ({args}){body} {{}}\n"


        struct += get_indent(1) + "__device__ auto &operator[](oc_uint i) noexcept { return cols[i]; }\n"
        struct += get_indent(1) + "__device__ auto operator[](oc_uint i) const noexcept { return cols[i]; }\n"
        struct += "};\n \n"
        content += struct

def matrix_operator():
    global content
    operator = ["+", "-", "*", "/"]
    for dim in range(2, 5):
        for scalar in scalar_types[:3]:
            for op in operator:
                func = f"__device__ auto operator{op}(oc_float{dim}x{dim} m, oc_{scalar} s) {{\n"
                func1 = f"__device__ auto operator{op}(oc_{scalar} s, oc_float{dim}x{dim} m) {{\n"
                args = ""
                args1 = ""
                for d in range(0, dim):
                    split = ", " if d != dim - 1 else ""
                    args += f"m[{d}] {op} s" + split
                    args1 += f"s {op} m[{d}]" + split
                func += get_indent(1) + f"return oc_float{dim}x{dim}({args});\n"
                func1 += get_indent(1) + f"return oc_float{dim}x{dim}({args1});\n"
                func += "}\n"
                func1 += "}\n"
                content += func
                content += func1
        
        op = "*"
        func = f"__device__ auto operator{op}(oc_float{dim}x{dim} m, oc_float{dim} v) {{\n"
        args = args = f""
        for d in range(0, dim):
            split = " + " if d != dim - 1 else ""
            args += f"v[{d}] {op} m[{d}]" + split
        func += get_indent(1) + "return %s;\n" % (args) 
        func += "}\n"
        content += func
            
        for op in operator[:3]:
            if op != "*":
                func = f"__device__ auto operator{op}(oc_float{dim}x{dim} lhs, oc_float{dim}x{dim} rhs) {{\n"
                args = f"oc_float{dim}x{dim}("
                for d in range(0, dim):
                    split = ", " if d != dim - 1 else ")"
                    args += f"lhs[{d}] {op} rhs[{d}]" + split
                func += get_indent(1) + "return %s;\n" % (args) 
                func += "}\n"
                content += func
            else:
                func = f"__device__ auto operator{op}(oc_float{dim}x{dim} lhs, oc_float{dim}x{dim} rhs) {{\n" 
                args = f"oc_float{dim}x{dim}("
                for d in range(0, dim):
                    split_m = ", " if d != dim - 1 else ")"
                    args += f"lhs {op} rhs[{d}]" + split_m
                func += get_indent(1) + "return %s;\n" % (args) 
                func += "}\n"
                content += func
    content += "\n"

def define_select():
    global content, name_lst
    for scalar in scalar_types:
        ret_type = f"{prefix}_{scalar}"
        func = f"__device__ {ret_type} {prefix}_select({prefix}_bool pred, {ret_type} t, {ret_type} f) {{"
        func += " return pred ? t : f; }"
        content += func
        content += "\n"   
        for dim in range(2, 5):
            ret_type = f"{prefix}_{scalar}{dim}"
            func = f"__device__ {ret_type} {prefix}_select({prefix}_bool{dim} pred, {ret_type} t, {ret_type} f) {{\n"
            args = f"return {ret_type}("
            for d in range(0, dim):
                field_name = name_lst[d]
                split = ", " if d != dim - 1 else ");\n}"
                args += f"{prefix}_select(pred.{field_name}, t.{field_name}, f.{field_name})" + split
            func += get_indent(1) + args
            content += func
            content += "\n"  
        content += "\n"
        
    content += """
template<typename P, typename T, oc_uint N>
[[nodiscard]] __device__ oc_array<T, N> oc_select(const oc_array<P, N> &pred, const oc_array<T, N> &t, const oc_array<T, N> &f) noexcept {
    oc_array<T, N> ret{};
    for(oc_uint i = 0; i < N; ++i) {
        ret[i] = oc_select(static_cast<oc_bool>(pred[i]), t[i], f[i]);
    }
    return ret;
}

"""
            
def define_unary_func(func_name, need_array, param):
    global content, name_lst
    body, types = param
    for elm in types:
        if len(elm) == 1:
            scalar = elm[0]
            ret_t = elm[0]
        else:
            scalar = elm[0]
            ret_t = elm[1]
        ret_type = f"{prefix}_{ret_t}"
        arg_type = f"{prefix}_{scalar}"
        func = f"__device__ {ret_type} {prefix}_{func_name}({arg_type} v) {{ {body} }}\n"
        content += func
        for dim in range(2, 5):
            ret_type = f"{prefix}_{ret_t}{dim}"
            arg_type = f"{prefix}_{scalar}{dim}"
            body2 = f"return {ret_type}("
            for d in range(0,dim):
                split = ", " if d != dim - 1 else ");"
                field_name = name_lst[d]
                body2 += f"{prefix}_{func_name}(v.{field_name})" + split
            func = f"__device__ {ret_type} {prefix}_{func_name}({arg_type} v) {{ {body2} }}\n"
            content += func
        
    if need_array:
        t_body = f""
        t_elm_type = f"{prefix}_{scalar}"
        t_ret_type = f"oc_array<T, N>"
        t_body = f"\n    {t_ret_type} ret{{}};\n"
        t_body += f"    for(oc_uint i = 0; i < N; ++i) ret[i] = {prefix}_{func_name}(x[i]);\n    return ret;\n"
        ff = f"template<typename T, oc_uint N>\n__device__ {t_ret_type} {prefix}_{func_name}(oc_array<T, N> x) {{{t_body}}}\n"
        content += ff
        print(ff)
        
    content += "\n"
    
def define_unary_funcs():
    tab = [
        ["rcp", True , ["return 1.f / v;", [["int"], ["uint"], ["float"]]]],
        ["sign", True , ["return v >= 0 ? 1: -1;", [["int"], ["float"]]]],
        ["abs", False , ["return fabsf(v);", [["float"]]]],
        ["abs", True , ["return abs(v);", [["int"]]]],
        ["ceil", True , ["return ceilf(v);", [["float"]]]],
        ["floor", True , ["return floorf(v);", [["float"]]]],
        ["fract", True , ["return v - oc_floor(v);", [["float"]]]],
        ["round", True , ["return roundf(v);", [["float"]]]],
        ["sin", True , ["return sinf(v);",[["float"]]]],
        ["cos", True , ["return cosf(v);", [["float"]]]],
        ["tan", True , ["return tanf(v);", [["float"]]]],
        ["sinh", True , ["return sinhf(v);",[["float"]]]],
        ["cosh", True , ["return coshf(v);", [["float"]]]],
        ["tanh", True , ["return tanhf(v);", [["float"]]]],
        ["asin", True , ["return asinf(v);", [["float"]]]],
        ["acos", True , ["return acosf(v);", [["float"]]]],
        ["atan", True , ["return atanf(v);", [["float"]]]],
        ["asinh", True , ["return asinhf(v);", [["float"]]]],
        ["acosh", True , ["return acoshf(v);", [["float"]]]],
        ["atanh", True , ["return atanhf(v);", [["float"]]]],
        ["is_inf", False , ["return isinf(v);", [["float", "bool"]]]],
        ["is_nan", False , ["return isnan(v);", [["float", "bool"]]]],
        ["is_inf", True , ["return false;", [["int","bool"], ["uint","bool"]]]],
        ["is_nan", True , ["return false;", [["int","bool"], ["uint","bool"]]]],
        ["exp", True , ["return expf(v);",[["float"]]]],
        ["exp2", True , ["return exp2f(v);",[["float"]]]],
        ["exp10", True , ["return exp10f(v);",[["float"]]]],
        ["log", True , ["return logf(v);",[["float"]]]],
        ["log2", True , ["return log2f(v);",[["float"]]]],
        ["log10", True , ["return log10f(v);",[["float"]]]],
        ["sqr", True , ["return v * v;",[["int"],["uint"],["float"]]]],
        ["sqrt", True , ["return sqrtf(v);",[["float"]]]],
        ["rsqrt", True , ["return rsqrtf(v);",[["float"]]]],
        ["degrees", True , ["return v * (180.f / 3.1415926535f);",[["float"]]]],
        ["radians", True , ["return v * (3.1415926535f / 180.f);",[["float"]]]],
        ["saturate", True , ["return fminf(1.f, fmaxf(0.f, v));",[["float"]]]],
    ]
    for k, a, v in tab:
        define_unary_func(k,a, v)
        
def define_binary_func(func_name, param):
    global content, name_lst
    body, types = param
    for scalar in types:
        ret_type = f"{prefix}_{scalar}"
        func = f"__device__ {ret_type} {prefix}_{func_name}({ret_type} lhs, {ret_type} rhs) {{ {body} }}\n"
        content += func
        for dim in range(2, 5):
            ret_type = f"{prefix}_{scalar}{dim}"
            body2 = f"return {ret_type}("
            for d in range(0,dim):
                split = ", " if d != dim - 1 else ");"
                field_name = name_lst[d]
                body2 += f"{prefix}_{func_name}(lhs.{field_name}, rhs.{field_name})" + split
            func = f"__device__ {ret_type} {prefix}_{func_name}({ret_type} lhs, {ret_type} rhs) {{ {body2} }}\n"
            content += func
    content += "\n"      


def define_binary_funcs():
    tab = {
        "pow" : ["return powf(lhs, rhs);", ["float"]],
        "fmod" : ["return fmodf(lhs, rhs);", ["float"]],
        "mod" : ["return lhs - rhs * oc_floor(lhs / rhs);", ["float"]],
        "min" : ["return fminf(lhs, rhs);", ["int", "uint", "float"]],
        "max" : ["return fmaxf(lhs, rhs);", ["int", "uint", "float"]],
        "atan2" : ["return atan2f(lhs, rhs);", ["float"]],
        "copysign" : ["return ::copysignf(lhs, rhs);", ["float"]],
    }
    for k, v in tab.items():
        define_binary_func(k, v)

def define_triple_func(tab):
    global content, name_lst
    func_name = tab["name"]
    body = tab["body"]
    types = tab.get("types", scalar_types)
    for scalar in types:
        arg_type = f"{prefix}_{scalar}"
        ret_type = f"{prefix}_{scalar}"
        scalar_func = f"__device__ {ret_type} {prefix}_{func_name}({arg_type} v0, {arg_type} v1, {arg_type} v2) {{ {body} }}\n"
        content += scalar_func
        for dim in range(2, 5):
            vec_ret_type = f"{ret_type}{dim}"
            vec_body = f"return {vec_ret_type}("
            for d in range(0, dim):
                split = ", " if d != dim - 1 else ");"
                field_name = name_lst[d]
                vec_body += f"{prefix}_{func_name}(v0.{field_name}, v1.{field_name}, v2.{field_name})" + split
            vec_func = f"__device__ {vec_ret_type} {prefix}_{func_name}({arg_type}{dim} v0, {arg_type}{dim} v1, {arg_type}{dim} v2) {{ {vec_body} }}\n"
            content += vec_func
    content += "\n"

def define_triple_funcs():
    lst = [
        {
            "name" : "lerp",
            "body" : "return v1 + v0 * (v2 - v1);",
            "types" : ["float"]
        },
        {
            "name" : "clamp",
            "body" : "return oc_min(v2, oc_max(v1, v0));",
            "types" : ["float", "uint", "int"]
        },
        {
            "name" : "fma",
            "body" : "return fmaf(v0, v1, v2);",
            "types" : ["float"]
        }
    ]
    for v in lst:
        define_triple_func(v)

def define_vec_func():
    global content, name_lst
    for dim in range(2, 5):
        body = "return "        
        for d in range(0, dim):
            field_name = name_lst[d]
            split = " + " if d != dim - 1 else ";"
            body += f"a.{field_name} * b.{field_name}" + split
        func = f"__device__ inline auto oc_dot(oc_float{dim} a, oc_float{dim} b) {{ {body} }}\n"
        content += func
        content += f"__device__ inline auto oc_length(oc_float{dim} v) noexcept {{ return oc_sqrt(oc_dot(v, v)); }}\n"
        content += f"__device__ inline auto oc_length_squared(oc_float{dim} v) noexcept {{ return oc_dot(v, v); }}\n"
        content += f"__device__ inline auto oc_distance(oc_float{dim} a, oc_float{dim} b) noexcept {{ return oc_length(a - b); }}\n"
        content += f"__device__ inline auto oc_distance_squared(oc_float{dim} a, oc_float{dim} b) noexcept {{ return oc_length_squared(a - b); }}\n"
        content += f"__device__ inline auto oc_normalize(oc_float{dim} v) noexcept {{ return v * oc_rsqrt(oc_dot(v, v)); }}\n"
        content += "\n"


    for scalar in scalar_types[:3]:
        content += f"[[nodiscard]] __device__ inline auto oc_cross(oc_{scalar}3 u, oc_{scalar}3 v) noexcept {{ return oc_{scalar}3(u.y * v.z - v.y * u.z, u.z * v.x - v.z * u.x, u.x * v.y - v.x * u.y);  }}\n"
    

    content += "\n"
        
def define_make_vecs():
    global content,name_lst
    for type in scalar_types:
        content += f"""[[nodiscard]] __device__ inline auto oc_make_{type}2(oc_{type} s = 0) noexcept {{ return oc_{type}2{{s, s}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}2(oc_{type} x, oc_{type} y) noexcept {{ return oc_{type}2{{x, y}}; }}""" + "\n"

        for t in scalar_types:
            for l in range(2, 5):
                content += f"[[nodiscard]] __device__ inline auto oc_make_{type}2(oc_{t}{l} v) noexcept {{ return oc_{type}2{{static_cast<oc_{type}>(v.x), static_cast<oc_{type}>(v.y)}}; }}"
                content += "\n"
        content += f"""[[nodiscard]] __device__ inline auto oc_make_{type}3(oc_{type} s = 0) noexcept {{ return oc_{type}3{{s, s, s}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}3(oc_{type} x, oc_{type} y, oc_{type} z) noexcept {{ return oc_{type}3{{x, y, z}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}3(oc_{type} x, oc_{type}2 yz) noexcept {{ return oc_{type}3{{x, yz.x, yz.y}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}3(oc_{type}2 xy, oc_{type} z) noexcept {{ return oc_{type}3{{xy.x, xy.y, z}}; }}""" + "\n"

        for t in scalar_types:
            for l in range(3, 5):
                
                content += f"[[nodiscard]] __device__ inline auto oc_make_{type}3(oc_{t}{l} v) noexcept {{ return oc_{type}3{{static_cast<oc_{type}>(v.x), static_cast<oc_{type}>(v.y), static_cast<oc_{type}>(v.z)}}; }}" 
                content += "\n"
        # make type4
        content += f"""[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{type} s = 0) noexcept {{ return oc_{type}4{{s, s, s, s}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{type} x, oc_{type} y, oc_{type} z, oc_{type} w) noexcept {{ return oc_{type}4{{x, y, z, w}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{type} x, oc_{type} y, oc_{type}2 zw) noexcept {{ return oc_{type}4{{x, y, zw.x, zw.y}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{type} x, oc_{type}2 yz, oc_{type} w) noexcept {{ return oc_{type}4{{x, yz.x, yz.y, w}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{type}2 xy, oc_{type} z, oc_{type} w) noexcept {{ return oc_{type}4{{xy.x, xy.y, z, w}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{type}2 xy, oc_{type}2 zw) noexcept {{ return oc_{type}4{{xy.x, xy.y, zw.x, zw.y}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{type} x, oc_{type}3 yzw) noexcept {{ return oc_{type}4{{x, yzw.x, yzw.y, yzw.z}}; }}
[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{type}3 xyz, oc_{type} w) noexcept {{ return oc_{type}4{{xyz.x, xyz.y, xyz.z, w}}; }}\n"""

        for t in scalar_types:
            content += f"[[nodiscard]] __device__ inline auto oc_make_{type}4(oc_{t}4 v) noexcept {{ return oc_{type}4{{static_cast<oc_{type}>(v.x), static_cast<oc_{type}>(v.y), static_cast<oc_{type}>(v.z), static_cast<oc_{type}>(v.w)}}; }}"
            content += "\n"


    content += "\n"

def define_make_matrix():
    global content,name_lst
    for i in range(2, 5):
        def init(j):
            return ', '.join(["0.0f", "0.0f", "0.0f", "s", "0.0f", "0.0f", "0.0f"][3 - j:3 + i - j])


        content += f"""
[[nodiscard]] __device__ inline auto oc_make_float{i}x{i}(oc_float s = 1.0f) noexcept {{ return oc_float{i}x{i}{{{", ".join(f"oc_make_float{i}({init(j)})" for j in range(i))}}}; }}
[[nodiscard]] __device__ inline auto oc_make_float{i}x{i}({', '.join(', '.join(f"oc_float m{j}{k}" for k in range(i)) for j in range(i))}) noexcept {{ return oc_float{i}x{i}{{{", ".join(f"oc_make_float{i}({', '.join(f'm{j}{k}' for k in range(i))})" for j in range(i))}}}; }}
[[nodiscard]] __device__ inline auto oc_make_float{i}x{i}({", ".join(f"oc_float{i} c{j}" for j in range(i))}) noexcept {{ return oc_float{i}x{i}{{{", ".join(f"c{j}" for j in range(i))}}}; }}"""
        content += "\n"
        if i == 3:
            
            content += f"[[nodiscard]] __device__ inline auto oc_make_float{i}x{i}(oc_float2x2 m) noexcept {{ return oc_float3x3{{oc_make_float3(m[0], 0.0f), oc_make_float3(m[1], 0.0f), oc_make_float3(0.0f, 0.0f, 1.0f)}}; }}"
            content += "\n"
        if i == 4:
            content += f"[[nodiscard]] __device__ inline auto oc_make_float{i}x{i}(oc_float2x2 m) noexcept {{ return oc_float4x4{{oc_make_float4(m[0], 0.0f, 0.0f), oc_make_float4(m[1], 0.0f, 0.0f), oc_make_float4(0.0f, 0.0f, 0.0f, 0.0f), oc_make_float4(0.0f, 0.0f, 0.0f, 1.0f)}}; }}"
            content += "\n"
            content += f"[[nodiscard]] __device__ inline auto oc_make_float{i}x{i}(oc_float3x3 m) noexcept {{ return oc_float4x4{{oc_make_float4(m[0], 0.0f), oc_make_float4(m[1], 0.0f), oc_make_float4(m[2], 0.0f), oc_make_float4(0.0f, 0.0f, 0.0f, 1.0f)}}; }}"
            content += "\n"
        content += f"[[nodiscard]] __device__ inline auto oc_make_float{i}x{i}(oc_float{i}x{i} m) noexcept {{ return m; }}"
        content += "\n"
        for t in range(i + 1, 5):
            content += f"[[nodiscard]] __device__ inline auto oc_make_float{i}x{i}(oc_float{t}x{t} m) noexcept {{ return oc_float{i}x{i}{{{', '.join(f'oc_make_float{i}(m[{j}])' for j in range(i))}}}; }}"
            content += "\n"

def convert_cuda_device_resource():
    curr_dir = dirname(realpath(__file__))
    cuda_device_resource = "cuda_device_resource"

    print(os.path.join(curr_dir, cuda_device_resource + ".h"))
    
    with open(os.path.join(curr_dir, cuda_device_resource + ".h"), "r") as file:
        string = file.read()
        file.close()
        save_to_inl(cuda_device_resource, string, os.path.join(curr_dir, cuda_device_resource + "_embed.h"))

def convert_optix_device_header():
    curr_dir = dirname(realpath(__file__))
    optix_device_header = "optix_device_header"

    print(os.path.join(curr_dir, optix_device_header + ".h"))
    
    with open(os.path.join(curr_dir, optix_device_header + ".h"), "r") as file:
        string = file.read()
        file.close()
        save_to_inl(optix_device_header, string, os.path.join(curr_dir, optix_device_header + "_embed.h"))

def save_to_inl(var_name, content, fn):
    string = f"static const char {var_name}[] = " + "{\n    "
    line_len = 20
    for i,s in enumerate(content):
        split = ", " if i != len(content) - 1 else ""
        string += f"{format(ord(s), '#04x')}" + split

        if i % line_len == line_len - 1:
            string += "\n    "
    string += "};"
    with open(fn, "w") as file:
        file.write(file_head() + string)
        file.close()

def convert_cuda_math():
    curr_dir = dirname(realpath(__file__))
    cuda_math = "cuda_device_math"

    print(os.path.join(curr_dir, cuda_math + ".h"))
    
    with open(os.path.join(curr_dir, cuda_math + ".h"), "r") as file:
        string = file.read()
        file.close()
        save_to_inl(cuda_math, string, os.path.join(curr_dir, cuda_math + "_embed.h"))

def main():
    global content
    curr_dir = dirname(realpath(__file__))
    using_scalar()
    define_vector()
    define_array()
    define_operator()
    define_matrix()
    matrix_operator()
    define_select()
    define_unary_funcs()
    define_binary_funcs()
    define_triple_funcs()
    convert_cuda_math()
    convert_cuda_device_resource()
    convert_optix_device_header()
    define_vec_func()
    define_make_vecs()
    define_make_matrix()

    content += "\n "

    cuda_builtin = "cuda_device_builtin"
    with open(os.path.join(curr_dir, cuda_builtin + ".h"), "w") as file:
        file.write(content)
        file.close()
    
    save_to_inl(cuda_builtin, content, os.path.join(curr_dir, cuda_builtin + "_embed.h"))
    # print(content)

if __name__ == "__main__":
    main()