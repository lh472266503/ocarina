from ast import operator
from ctypes import alignment
from os.path import realpath, dirname
import os
from posixpath import split

scalar_types = ["int", "uint", "float", "bool"]
native_types = ["int", "unsigned int", "float", "bool"]
vector_alignments = {2: 8, 3: 16, 4: 16}
indent = "\t"
name_lst = ["x", "y", "z", "w"]
device_flag = "__device__"

prefix = "oc"

cur_fn = os.path.basename(__file__)

def file_head():
    return f"// this file was generated by {cur_fn}, please do not manually modify \n \n"

content = file_head() + "#pragma once\n\n"

def get_indent(num = 1):
    return indent * num

def using_scalar():
    global content
    string = ""
    for i,scalar in enumerate(scalar_types):
        string += f"using {prefix}_{scalar} = {native_types[i]};\n"
    
    content += string

def emit_member(scalar_name, dim):
    ret = "\n"
    for d in range(0, dim):
        ret += indent + scalar_name + " " + name_lst[d] + ";\n"
    return ret

def emit_functions(scalar_name, dim):
    ret = "\n"
    struct_name = f"{scalar_name}{dim}"

    ret += indent + f"{device_flag} {struct_name}() noexcept \n" + get_indent(2) + ":"
    for d in range(0, dim):
        split = ", " if d != dim - 1 else ""
        ret += f"{name_lst[d]}{{}}" + split 
    ret += " {}\n"

    ret += indent + f"{device_flag} {struct_name}({scalar_name} s) noexcept \n" + get_indent(2) + ":"
    for d in range(0, dim):
        split = ", " if d != dim - 1 else ""
        ret += f"{name_lst[d]}(s)" + split 
    ret += " {}\n"

    args = ""
    assign = ""
    for d in range(0, dim):
        split = ", " if d != dim - 1 else ""
        member_name = name_lst[d]
        args += f"{scalar_name} {member_name}" + split
        assign += f"{member_name}({member_name})" + split 
    ret += indent + f"{device_flag} {struct_name}({args}) noexcept \n" + get_indent(2) + ":"
    ret += assign
    ret += " {}\n"

    access = f"{device_flag} constexpr {scalar_name} operator[]({prefix}_uint i) const noexcept %s\n" % ("{ return (&x)[i]; }")
    access += indent + f"{device_flag} constexpr {scalar_name} &operator[]({prefix}_uint i) noexcept %s\n" % ("{ return (&x)[i]; }")
    ret += indent + access

    return ret

def define_vector():
    global content
    content += "\n"
    for j, scalar in enumerate(scalar_types):
        for dim in range(2, 5):
            alignment = vector_alignments[dim]
            scalar_name = f"{prefix}_{scalar}"
            struct_name = f"struct alignas({alignment}) {scalar_name}{dim}" + "{"
            content += struct_name
            body = emit_member(scalar_name, dim)
            body += emit_functions(scalar_name, dim)
            content += body
            content += "};\n\n"

def define_operator():
    global content
    unary = ["+", "-", "!", "~"]
    for i, scalar in enumerate(scalar_types):
        for dim in range(2, 5):
            for op in unary:
                if op == "~" and scalar == "float":
                    continue
                class_name = f"{prefix}_{scalar}{dim}"
                args = ""
                for d in range(0, dim):
                    split = ", " if d != dim - 1 else ""
                    args += f"{op}vec.{name_lst[d]}" + split
                func = f"{device_flag} {class_name} operator{op}({class_name} vec) {{ return {class_name}({args}); }}"
                content += func + "\n"
            content += "\n"
    content += "\n"     
    cal_binary = ["+", "-", "*", "/", "%"]
    cmp_binary = ["==", "!=", ">" , "<", ">=", "<=","&&", "||"]
    bit_binary = ["&", "|", "^", "<<", ">>"]
    binary = cal_binary + cmp_binary + bit_binary
    for i, scalar in enumerate(scalar_types):
        for dim in range(2, 5):
            for op in binary:
                if scalar == "bool" and (op in cal_binary):
                    continue
                if scalar == "float" and (op == "%" or op in bit_binary):
                    continue
                vec_name = f"{prefix}_{scalar}{dim}"
                ret_type = vec_name
                if op in cmp_binary:
                    ret_type = f"{prefix}_bool{dim}"
                scalar_name = f"{prefix}_{scalar}"
                args = ""
                args1 = ""
                args2 = ""
                for d in range(0, dim):
                    field_name = name_lst[d]
                    split = ", " if d != dim - 1 else ""
                    args += f"lhs.{field_name} {op} rhs.{field_name}" + split
                    args1 += f"lhs.{field_name} {op} rhs" + split
                    args2 += f"lhs {op} rhs.{field_name}" + split
                    
                func = f"{device_flag} {ret_type} operator{op}({vec_name} lhs, {vec_name} rhs) {{ return {ret_type}({args}); }}\n"
                func += f"{device_flag} {ret_type} operator{op}({vec_name} lhs, {scalar_name} rhs) {{ return {ret_type}({args1}); }}\n"
                func += f"{device_flag} {ret_type} operator{op}({scalar_name} lhs, {vec_name} rhs) {{ return {ret_type}({args2}); }}\n"
                content += func
        content += "\n"
    func_lst = ["oc_any", "oc_all", "oc_none"]
    for func in func_lst:
        for dim in range(2, 5):
            ret_type = f"{prefix}_bool"
            arg_type = f"{prefix}_bool{dim}"
            op = " || " if func == "oc_any" else " && "
            ret = ""
            if func != "oc_none":
                for d in range(0, dim):
                    split = op if d != dim - 1 else ""
                    field_name = name_lst[d]
                    ret += f"vec.{field_name}" + split
            else:
                ret = "!oc_any(vec)"
                
            string = f"{device_flag} {ret_type} {func}({arg_type} vec) {{ return {ret}; }}" 
            content += string + "\n"
    content += "\n"
    
def define_matrix():
    global content
    struct = ""
    for dim in range(2, 5):
        struct = f"struct {prefix}_float{dim}x{dim} {{\n"
        struct += get_indent(1) + f"{prefix}_float{dim} cols[{dim}];\n"
        struct += get_indent(1) + f"__device__ explicit constexpr {prefix}_float{dim}x{dim}({prefix}_float s = 1.f)\n"
        args = ""
        for d in range(0, dim):
            split = ", " if d != dim - 1 else ""

            vec = f"{prefix}_float{dim}("
            for j in range(0, dim):
                split_j = ", " if j != dim - 1 else ")"
                scalar = "s" if j == d else "0.f"
                vec += scalar + split_j
            args += vec + split
        struct += get_indent(2) + f":cols{{{args}}} {{}}\n"
        
        args = ""
        lst = ""
        for d in range(0, dim):
            split = ", " if d != dim - 1 else ""
            args += f"{prefix}_float{dim} c{d}" + split
            lst += f"c{d}" + split
        struct += get_indent(1) + f"__device__ {prefix}_float{dim}x{dim}({args})\n"
        struct += get_indent(2) + f":cols{{{lst}}} {{}}\n"
        struct += get_indent(1) + "__device__ auto &operator[](oc_uint i) noexcept { return cols[i]; }\n"
        struct += get_indent(1) + "__device__ auto operator[](oc_uint i) const noexcept { return cols[i]; }\n"
        struct += "};\n \n"
        content += struct

def matrix_operator():
    global content
    operator = ["+", "-", "*", "/"]
    for dim in range(2, 5):
        for scalar in scalar_types[:3]:
            for op in operator:
                func = f"__device__ auto operator{op}(oc_float{dim}x{dim} m, oc_{scalar} s) {{\n"
                func1 = f"__device__ auto operator{op}(oc_{scalar} s, oc_float{dim}x{dim} m) {{\n"
                args = ""
                args1 = ""
                for d in range(0, dim):
                    split = ", " if d != dim - 1 else ""
                    args += f"m[{d}] {op} s" + split
                    args1 += f"s {op} m[{d}]" + split
                func += get_indent(1) + f"return oc_float{dim}x{dim}({args});\n"
                func1 += get_indent(1) + f"return oc_float{dim}x{dim}({args1});\n"
                func += "}\n"
                func1 += "}\n"
                content += func
                content += func1
        
        op = "*"
        func = f"__device__ auto operator{op}(oc_float{dim}x{dim} m, oc_float{dim} v) {{\n"
        args = args = f""
        for d in range(0, dim):
            split = " + " if d != dim - 1 else ""
            args += f"v[{d}] {op} m[{d}]" + split
        func += get_indent(1) + "return %s;\n" % (args) 
        func += "}\n"
        content += func
            
        for op in operator[:3]:
            if op != "*":
                func = f"__device__ auto operator{op}(oc_float{dim}x{dim} lhs, oc_float{dim}x{dim} rhs) {{\n"
                args = f"oc_float{dim}x{dim}("
                for d in range(0, dim):
                    split = ", " if d != dim - 1 else ")"
                    args += f"lhs[{d}] {op} rhs[{d}]" + split
                func += get_indent(1) + "return %s;\n" % (args) 
                func += "}\n"
                content += func
            else:
                func = f"__device__ auto operator{op}(oc_float{dim}x{dim} lhs, oc_float{dim}x{dim} rhs) {{\n" 
                args = f"oc_float{dim}x{dim}("
                for d in range(0, dim):
                    split_m = ", " if d != dim - 1 else ")"
                    args += f"lhs {op} rhs[{d}]" + split_m
                func += get_indent(1) + "return %s;\n" % (args) 
                func += "}\n"
                content += func
    content += "\n"

def define_select():
    global content
    for scalar in scalar_types:
        ret_type = f"{prefix}_{scalar}"
        func = f"__device__ {ret_type} {prefix}_select({prefix}_bool pred, {ret_type} t, {ret_type} f) {{"
        func += " return pred ? t : f; }"
        content += func
        content += "\n"       



def save_to_inl(var_name, content, fn):
    string = f"static const char {var_name}[] = " + "{\n    "
    line_len = 20
    for i,s in enumerate(content):
        split = ", " if i != len(content) - 1 else ""
        string += f"{format(ord(s), '#04x')}" + split

        if i % line_len == line_len - 1:
            string += "\n    "
    string += "};"
    with open(fn, "w") as file:
        file.write(file_head() + string)
        file.close()

def main():
    global content
    curr_dir = dirname(realpath(__file__))
    using_scalar()
    define_vector()
    define_operator()
    define_matrix()
    matrix_operator()
    define_select()
    content += " "

    math_lib = "cuda_math_lib"
    with open(os.path.join(curr_dir, math_lib + ".h"), "w") as file:
        file.write(content)
        file.close()
    
    save_to_inl(math_lib, content, os.path.join(curr_dir, math_lib + "_embed.h"))
    # print(content)

if __name__ == "__main__":
    main()